<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ This is part of Geomajas, a GIS framework, http://www.geomajas.org/.
  ~
  ~ Copyright 2008-2015 Geosparc nv, http://www.geosparc.com/, Belgium.
  ~
  ~ The program is available in open source according to the GNU Affero
  ~ General Public License. All contributions in this program are covered
  ~ by the Geomajas Contributors License Agreement. For full licensing
  ~ details, see LICENSE.txt in the project root.
  -->
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<part id="part-architecture">
  <title>Architecture</title>

  <chapter id="chapter-architecture">
    <title>Architecture</title>

    <para>Geomajas is an application framework which allows building powerful
    GIS application. We will try to look at the architecture starting from a
    high level overview, drilling down to discover more details.</para>

    <para>At the highest level, Geomajas makes a distinction between the
    <glossterm>server</glossterm> and <glossterm>clients</glossterm>.</para>

    <figure>
      <title>Geomajas server and clients</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/geomajas-server-client.svg" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The server is where you configure your maps, layers and
    attributes/features. It is always server side. The server has an API for
    interaction with the outside world and for extension using plug-ins. While
    one of the main purposes of the server is to provide bitmaps and vector
    graphics for the maps and provide data about features to be rendered and
    edited, it contains no display code.</para>

    <para>The actual display and editing is done in the clients. The server is
    agnostic of web (or other) display frameworks. Often, clients will consist of
        multiple modules. The actual client module(s), that could run standalone without a server,
        will not contact the server directly. Rather, an extra module in the client, the server-extension module,
        will act as an intermediate: the client's server-extension talks directly to the server
    using java calls, while the actual client modules only talks to the client's server-extension module. The communication
    between the two modules is private to the client. The client itself provides a
    additional client API. This will typically provide details about available
    widgets, parameters for these widgets and other possible interactions
    (like message queues or topics you can subscribe to).</para>

    <para>The purpose of Geomajas is to provide rich editing of GIS data in
    the browser, but the clients also make other applications possible. You
    could unlock the maps which are configured in Geomajas using a client which
    makes data available as web services (this would result in a client with
    only a server-extension module). You could also build a java swing application
    using the Geomajas server by writing a swing client. This would result in
    a thick client application (possibly accessible using Java Web
    Start).</para>

    <para>Geomajas contains two GWT based clients. The GWT2 client (from 2.x on) uses GWT libraries only.
    The older GWT client (1.x versions) also uses SmartGwt widgets. They both allow all development to
    be done in Java and GWT will handle conversion to Javascript for code
    which needs to run in the browser. Obviously this integrates best with GWT
    based applications, but it can be combined with other web frameworks as
    well.</para>

    <figure>
      <title>Geomajas services</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/services_logo.png" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Geomajas server is built from many services which are wired
    together using dependency injection (DI). This wiring is partly done
    automatically, and partly through the configuration files. Thanks to the
    inversion of control (IoC) the server is very flexible and can be
    customized at will.</para>

    <para>The client-server communication is done through the command
    dispatcher. This delegates to one of the action based services which
    handle the command. These typically interact with one or more of the topic
    based services (though the command could also handle everything directly).
    The most important built-in topic based services are the raster and vector
    layer service. They are used to access the GIS data which is stored as
    either raster or vector layer.</para>

    <para>All the services are running in a secured zone and will typically
    interact with the security context to verify access rights (or
    policies).</para>

    <para>The layers access the actual GIS data, either directly or using some
    kind of transformation service (for example a GeoServer or MapServer
    instance).</para>

    <figure>
      <title>Geomajas for mashups</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/mashup_logo.png" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>With this advanced configuration, many integration options exist.
    One example is displayed above, the inclusion of Geomajas in an existing
    application. On the client side, you just have to include the map widget
    in your web application. On the server side, there are many options, but
    you could for example assure that the transactions are shared between your
    existing application and Geomajas.</para>

    <figure>
      <title>Geomajas dependencies</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/geomajas-dependencies.svg" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>As is the case for most powerful frameworks, Geomajas stands on the
    shoulder of giants. We use some of the major open source libraries in our
    framework (and we integrate with a lot more).</para>

    <figure>
      <title>Geomajas server modules</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/geomajas-server.svg" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Geomajas server is itself built from several modules which are
    tied together using the Spring framework (<ulink
    url="http://springframework.org/">http://springframework.org/</ulink>).
    The Geomajas-api module is a set of interfaces which shields
    implementation details between the different modules. The base plumbing
    and some generic features are provided by the Geomajas-impl module.</para>

    <para>There are four possible ways to extend the server.</para>

    <para><orderedlist>
        <listitem>
          <para><emphasis>command</emphasis>: commands are used as main
          interaction point between the client and the Geomajas
          server. The retrieval of maps and features, calculations, updates
          on the features and all all other functionalities which are
          available client-side are done using commands.</para>
        </listitem>

        <listitem>
          <para><emphasis>layer</emphasis>: this groups a set of access
          options for all details of the layers of a map. A layer can be
          either raster or vector based. A vector layer can be editable. The
          features describing the objects which are part of the vector layer
          are accessed through the "feature model" which converts generic
          feature objects into something Geomajas can use (this way, there is
          no need for the generic feature objects to implement a "feature"
          interface, allowing the use of pojos). A feature contains a geometry
          and can contain attributes, style and labels. Attributes can be
          complex, including one-to-many and many-to-one relations to other
          objects.</para>
        </listitem>

        <listitem>
          <para><emphasis>pipeline</emphasis>: all Geomajas server services
          which deal with layers are implemented using pipelines. A pipeline
          is a list of steps (actions) executed in order. Each pipeline can be
          overwritten for a layer, or you can change the default which is used
          when not overwritten for a layer.</para>

          <para>Configuring pipelines can be used to change the rendering
          method, add additional rendering steps (for example marking the
          editable area on a tile), to introduce caching,...</para>
        </listitem>

        <listitem>
          <para><emphasis>security</emphasis>: these modules contain the
          pluggable security features. You can configure the security services
          which are used to verify the validity of an authentication token and
          return the authorization objects based on it. These authorization
          objects can read the security policies from your (secure) policy
          store.</para>
        </listitem>
      </orderedlist></para>

    <section id="architecture-command">
      <title>Command</title>

      <figure>
        <title>Geomajas client and commands</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/server-command_logo.png" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The interaction of the client with the Geomajas server is
      handled using commands.</para>

      <orderedlist>
        <listitem>
          <para>When a command needs to be invoked (probably as result of a
          user interaction), the client will build a
          <code>CommandRequest</code> object. This contains the name of the
          command to be used, the parameters for the command, and optionally
          the user authentication token and language of the user
          interface.</para>
        </listitem>

        <listitem>
          <para>This object is transferred to the client's server-extension. For web
          applications, this will typically be done using an AJAX
          request.</para>
        </listitem>

        <listitem>
          <para>The client's server-extension will use this <code>CommandRequest</code> to
          invoke the <code>CommandDispatcher</code> service, which can be
          obtained using the Spring context.</para>
        </listitem>

        <listitem>
          <para>The <code>CommandDispatcher</code> will start by invoking the
          <code>SecurityManager</code> to check whether the execution of the
          requested command is allowed. If it is allowed, the actual Command
          is obtained using the Spring context. The
          <code>CommandResponse</code> object is created and the command is
          executed.</para>
        </listitem>

        <listitem>
          <para>The <code>Command</code> will now do its job, writing the
          results in the <code>CommandResponse</code> object. When problems
          occur during execution of the command, it can either write this into
          the response object or throw an exception.</para>
        </listitem>

        <listitem>
          <para>When the command has executed, if it threw an exception, the
          dispatcher will add this in the response object. It will then
          convert any exceptions in the response object into some messages
          which may be sensible to the user (put the message in the correct
          language in the result object, assuring the "cause" chain is also
          included). Some extra information is also added in the response
          object (like command execution time).</para>
        </listitem>

        <listitem>
          <para>The <code>CommandResponse</code> is returned to the client's
          server-extension.</para>
        </listitem>

        <listitem>
          <para>The client's server-extension serializes the <code>CommandResponse</code>
          back to the client.</para>
        </listitem>
      </orderedlist>

      <para>When the command had something to do with rendering, then the
      response object is likely to contain a <code>Tile</code>.</para>
    </section>

    <section id="arch-pipeline">
      <title>Pipelines</title>

      <para>Pipelines are used in Geomajas to allow extreme configurability of
      the services which choose to use them.</para>

      <para>They are comparable with Business Process Modeling (BPM) processes. At first sight pipelines
      are much more limited as the steps are always sequential, only allowing
      each step to either continue to the next stop or stop the pipeline.
      Nesting pipelines gives back the expressive power of general BPM
      processes. A step could loop over another pipeline, conditionally
      execute a pipeline, start several pipelines for parallel processing etc.
      An important difference is the configurability of pipelines. Pipelines
      are selected on a combination of pipeline name and the layer on which
      the pipeline operates. When defining pipelines, you can either define
      them from scratch, copy an existing pipeline or copy and extend a
      pipeline. A pipeline can be defined with extension hooks and these hooks
      can be used to add additional pipeline steps. You can also add
      interceptors on a pipeline which introduces some code to execute before
      and after the steps which are intercepted and allows you to skip the
      execution of the intercepted steps.</para>

      <figure>
        <title>Geomajas pipeline architecture</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/pipeline_logo.png" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <section id="arch-plarch">
        <title>Pipeline architecture</title>

        <para>All the layer access services provided by the Geomajas server
        are implemented by invoking a pipeline. Using
        <code>PipelineService</code>, blocks of functionality become reusable
        and highly configurable with limited coupling between the
        <emphasis>pipeline step</emphasis>s.</para>

        <para>Some of the services which are implemented as
        <code>PipelineService</code> include:</para>

        <para><itemizedlist>
            <listitem>
              <para><code>RasterLayerService</code>: methods for accessing a
              raster layer, especially getting tiles for a raster
              layer.</para>
            </listitem>

            <listitem>
              <para><code>VectorLayerService</code>: methods for accessing a
              vector layer, for example for getting the features or obtaining
              vector tiles.</para>
            </listitem>
          </itemizedlist>Pipelines can nest. One of the steps in the default
        "vectorLayer.saveOrUpdate" pipeline will loop over all features to be
        updated and invoke the "vectorLayer.saveOrUpdateOne" pipeline for
        each.</para>

        <para>Pipelines are server side only, client access is typically made
        available by invoking a command.</para>

        <para>Pipelines are typically invoked for a specific layer. In that
        case, the default pipeline can be replaced by a layer specific
        pipeline. This way, layer specific configurations (like optimizations
        or specific rendering) can be applied. When a layer does not overwrite
        a pipeline, the default is used. Pipelines are always selected on
        pipeline name. You can create the layer specific pipeline by setting
        the layer id for which it applied. When several pipelines have the
        same steps, you can define the pipeline once, and refer to it later by
        using a pipeline delegate instead of a list of steps.</para>

        <para>A pipeline consists of a number of steps. A pipeline is
        configured using a <code>PipelineInfo</code> object which details the
        pipeline id and steps. When a pipeline is started (using the
        <code>PipelineService</code>) it executes the pipeline steps until the
        pipeline is finished (a status which can be set by one of the steps),
        or until no more steps are available in the pipeline. Each step gets
        two parameters.</para>

        <para><itemizedlist>
            <listitem>
              <para>a context which contains a map of (typed) objects which
              can be used to pass data between the steps (including initial
              parameters for the pipeline).</para>
            </listitem>

            <listitem>
              <para>the result object which can be filled or transformed
              during the pipeline's execution.</para>
            </listitem>
          </itemizedlist></para>

        <para>Pipelines can be extended in two ways. When a pipeline is
        defined, it is possible to include hooks for extensions. These are
        special no-op steps. When a pipeline is defined, your can either
        define all the pipeline steps, or refer to a delegate pipeline
        combined with a map of extension steps. The pipeline will then be
        based on the delegate pipeline with the extensions steps added after
        the hooks with matching names.</para>

        <para>Pipelines can be also enhanced with interceptors. An interceptor
        will intercept a block of consecutive steps, allowing to perform an
        action before and after the block is executed. Depending on the return
        value of the before action, the steps (and optionally the after
        action) can be skipped. This can for example be used to implement
        functionality like caching and auditing.</para>
      </section>

      <section id="arch-pl-app">
        <title>Application in the server</title>

        <para>All the methods in both RasterLayerService and
        VectorLayerService are implemented using pipelines.</para>
      </section>
    </section>

    <section id="arch-layer">
      <title>Layer</title>

      <para>The layer extensions allow determining how a layer is built, which
      data is part of the layer, update and creation of extra data on a
      layer.</para>

      <para>A <code>Layer</code> has some metadata (id, coordinate system,
      label, bbox, stored in the <code>LayerInfo</code> object) and allows you
      get obtain the layer data.</para>
    </section>

    <section id="arch-securiry">
      <title>Security</title>

      <para>The data which is accessed using Geomajas can be security
      sensitive. Geomajas includes all the measures to assure protection of
      sensitive or private data.</para>

      <section id="arch-sec">
        <title>Security architecture</title>

        <para>Geomajas is built to be entirely independent of the
        authentication mechanism and the way to store policies.</para>

        <para>Based on the user who is logged into the system, the following
        restrictions can apply:</para>

        <itemizedlist>
          <listitem>
            <para>access rights to a command</para>
          </listitem>

          <listitem>
            <para>access rights for a layer</para>
          </listitem>

          <listitem>
            <para>a filter which needs to be applied for a layer</para>
          </listitem>

          <listitem>
            <para>a region which limits the data which may be accessed for a
            layer</para>
          </listitem>

          <listitem>
            <para>access rights on the features</para>
          </listitem>

          <listitem>
            <para>access rights on the individual attributes of the
            features</para>
          </listitem>
        </itemizedlist>

        <figure>
          <title>Security architecture</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/security_logo.png" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>To assure the authentication mechanism is pluggable, an
        <emphasis>authentication token</emphasis> is used. The authentication
        token is used to determine the <emphasis>security context</emphasis>.
        The security context contains the <emphasis>policies</emphasis> which
        apply and which can be queried.</para>

        <para>A list of <emphasis>security services</emphasis> can be defined
        (using Spring bean <code>security.SecurityInfo</code>). This list can
        be overwritten in configuration. By default the list is empty, which
        prohibits all access to everyone. The server does however include a
        security service which can be used to allow all access to
        everyone.</para>

        <para>The security service is responsible for converting the
        authentication token into a list of <emphasis>authorization
        objects</emphasis>. The security manager will loop all configured
        security services (using Spring bean
        <code>security.SecurityInfo</code>) to find all the authorization
        objects which apply for the token. By default the security manager
        will stop looping once one of the security services gave a result. You
        can change this behaviour to always combine the authorization objects
        from all security services.</para>

        <note>
          <para>The system explicitly allows authentication tokens to be
          generated by different authentication servers. In that case for each
          authentication server, at least one security service should be
          configured in Geomajas. However, when using such a configuration,
          you <emphasis>have to</emphasis> verify that the authentication
          tokens which are generated by the different servers cannot be the
          same.</para>
        </note>

        <para>In many systems (including Role-Based Access Control (RBAC) systems) an authorization object
        matches a roles for the authenticated user.</para>

        <para>Note that, as the actual authentication mechanisms are handled
        by the security services, Geomajas does not know any passwords or
        credentials. Similarly the secure, tamper-proof storage of policies is
        not handled by Geomajas either.</para>

        <para>Details about the current authentication token and access to the
        policies (using the authorization objects) is available using the
        <code>SecurityContext</code>. The security context is thread specific.
        When threads are reused between different users, the security context
        needs to be cleared at the end of a request (group). This is normally
        handled by the clients.</para>

        <para>The following general authorization checks exist:</para>

        <itemizedlist>
          <listitem>
            <para><code>isToolAuthorized(String toolId)</code>: true when the
            tool can be used. The "toolId" matches the "id" parameter which is
            used in the configuration as specified using the
            <code>ToolInfo</code> class.</para>
          </listitem>

          <listitem>
            <para><code>isCommandAuthorized(String commandName)</code>: true
            when the command is allowed to be called. The "commandName"
            parameter is the same as the command name which is passed to the
            <code>CommandDispatcher</code> service.</para>
          </listitem>
        </itemizedlist>

        <para>And for each layer:</para>

        <itemizedlist>
          <listitem>
            <para><code>isLayerVisible(String layerId)</code>: true when (part
            of) the layer is visible.</para>
          </listitem>

          <listitem>
            <para><code>isLayerUpdateAuthorized(String layerId)</code>: true
            when (some of) the visible features may be editable.</para>
          </listitem>

          <listitem>
            <para><code>isLayerCreateAuthorized(String layerId)</code>: true
            when there is an area in which features can be created.</para>
          </listitem>

          <listitem>
            <para><code>isLayerDeleteAuthorized(String layerId)</code>: true
            when (some of) the visible features may be deleted.</para>
          </listitem>

          <listitem>
            <para><code>getVisibleArea(String layerId)</code>: only the area
            inside the returned geometry is visible (uses layer coordinate
            space). All features which fall outside the layer's MaxExtent area
            are also considered not visible.</para>
          </listitem>

          <listitem>
            <para><code>getUpdateAuthorizedArea(String layerId)</code>: only
            the area inside the returned geometry may contain updatable
            features (uses layer coordinate space). All features which fall
            outside the layer's MaxExtent area are also considered not
            updatable.</para>
          </listitem>

          <listitem>
            <para><code>getCreateAuthorizedArea(String layerId)</code>: only
            the area inside the returned geometry can new features be created
            (uses layer coordinate space). All features which fall outside the
            layer's MaxExtent area are also considered not creatable.</para>
          </listitem>

          <listitem>
            <para><code>getDeleteAuthorizedArea(String layerId)</code>: only
            the area inside the returned geometry may contain deletable
            features (uses layer coordinate space). All features which fall
            outside the layer's MaxExtent area are also considered not
            deletable.</para>
          </listitem>

          <listitem>
            <para><code>getFeatureFilter(String layerId)</code>: get an
            additional filter which needs to be applied when querying the
            layer's features.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureVisible(String layerId, InternalFeature
            feature)</code>: check the visibility of a feature.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureUpdateAuthorized(String layerId,
            InternalFeature feature)</code>: check whether a feature is
            editable.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureUpdateAuthorized(String layerId,
            InternalFeature oldFeature, InternalFeature newFeature)</code>:
            check whether the update contained in the feature is allowed to be
            saved.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureCreateAuthorized(String layerId,
            InternalFeature feature)</code>: check whether a feature is
            allowed to be created.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureDeleteAuthorized(String layerId,
            InternalFeature feature)</code>: check whether deleting the
            specific feature is allowed.</para>
          </listitem>

          <listitem>
            <para><code>isAttributeReadable(String layerId, InternalFeature
            feature, String attributeName)</code>: check the readability of an
            attribute. The result can be feature specific.</para>
          </listitem>

          <listitem>
            <para><code>isAttributeWritable(String layerId, InternalFeature
            feature, String attributeName)</code>: check whether an attribute
            is editable. The result can be feature specific.</para>
          </listitem>
        </itemizedlist>

        <para>These authorizations are split in several groups. The security
        service is not required to provide an implementation of each
        authorization test (see API), the security context always ensures that
        all methods are available.</para>

        <para>Checking authentication and fetching the authorization details
        can be time consuming (not to mention the hassle of logging in again).
        To solve this, the results of the security services can be cached.
        When a security service can authenticate a token, the reply can
        contain details about the allowed caching. Three parameters are
        allowed to be passed, the <code>validUntil</code> and
        <code>invalidAfter</code> timestamps and an <code>extendValid</code>
        duration.</para>

        <para>The security manager first checks the cache to find (valid)
        authentication results. A cache entry is only valid until the
        "validUntil" timestamp. When an entry is valid, validUntil may be
        extended until "now" plus "extendValid" duration. However,
        "validUntil" is never extended past "invalidAfter". When no data can
        be found in the cache, the security services are queried.<note>
            <para>There may be multiple authentications stored for a
            authentication token. When one of them becomes invalid, they are
            all considered invalid.</para>
          </note><note>
            <para>Entering credentials is never handled by Geomajas. When the
            authentication token cannot be verified, a security exception is
            thrown. It is up to the client application to
            assure that a new authentication token is created.</para>
          </note></para>

        <para>The authorization have two possible results. When reading or
        rendering, all unauthorized data should be filtered without warning or
        exception. When trying to invoke a command or to create, update or
        delete, any attempt which is not authorized should result in a
        security exception.</para>

        <para>The security uses the approach that all access is forbidden
        unless is is allowed. Hence, you will always need to configure at
        least one security service to assure the system is usable.</para>
      </section>

      <section id="arch-sec-comm">
        <title>Interaction between client and server</title>

        <para>When a user wants to access a secured Geomajas application, she
        will normally surf to the URL for the application.</para>

        <para>The application will then check whether the user is logged in.
        If that is not the case, the user is redirected to the login page.
        This may be an external page as provided by an authentication server
        (as often used for SSO (Single-Sign-On) solutions), or it could be a
        login widget. Note that the framework does not handle this redirection
        itself or even know how the login can be handled. It is up to the
        application writer to provide this redirection.</para>

        <para>The login page will ask the user to provide her credentials.
        This could be a user name, password pair, a request for a code coming
        from a hardware device, login using a eID or some other means PKI
        (Private Key Infrastructure), automatic recognition based on IP
        address,... When the login handling is satisfied with the provided
        credentials (the user is really authenticated), it will redirect back
        to the original application with a security token.</para>

        <para>This token is then used by the client to pass authentication
        information to the server.</para>

        <para>As seen from this example, the Geomajas client does not handle
        the authentication and does not need to know the credentials for the
        user.</para>

        <figure>
          <title>Logging into a Geomajas system</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/security-login.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <note>
          <para>It is important to know that the security token typically has
          a limited validity. As such, it can happen at any moment that the
          token is no longer valid and the login screen needs to be presented
          again. The application author should consider this while
          developing.</para>
        </note>

        <para>At the server, the programmer has a reasonably simple job. At
        each policy enforcement point, you need an injected security context
        which can be used for the policy decisions. This can be included using
        the following piece of code.</para>

        <informalexample>
          <programlisting>@Autowired
private SecurityContext securityContext;</programlisting>
        </informalexample>

        <para>The framework handles the instantiation of this security context
        based on the security token (which is typically received either
        through the CommandDispatcher's request or a URL parameter). This is
        done by the SecurityManager. The SecurityManager uses the
        configuration supplied by Spring bean
        <code>security.SecurityInfo</code>. Each of the security services will
        check whether the token is valid (which includes checking whether it
        was supplied by the authentication services which backs the service)
        and extract the principal from the token. That principal is used to
        fill some information about the user (like name, to allow the client
        to display this) and to read the policies from the policy store. The
        policies are converted by the service to Authentication objects. The
        authentication objects are combined in the security context, only
        allowing things which are allowed by at least one authentication
        object.</para>

        <figure>
          <title>Building the security context</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/security-context.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Both the authentication service and policy store are outside of
        the Geomajas framework. They can be external services which are
        accessed by the security services or implemented as part of the
        security service implementation.</para>
      </section>

      <section id="arch-sec-app">
        <title>How is this applied ?</title>

        <para>The security is applied throughout Geomajas. A list of places
        (which is not necessarily complete) and some additional ideas for
        application follow.</para>

        <para>Server services:</para>

        <itemizedlist>
          <listitem>
            <para><code>CommandDispatcher</code> verifies the existence of a
            <code>SecurityContext</code> and creates one if needed.</para>
          </listitem>

          <listitem>
            <para><code>CommandDispatcher</code> verifies whether the command
            is allowed to be used.</para>
          </listitem>
        </itemizedlist>

        <para>VectorLayerService:</para>

        <itemizedlist>
          <listitem>
            <para>Check layer access.</para>
          </listitem>

          <listitem>
            <para>Handle the "filter" for the layer (if any).</para>
          </listitem>

          <listitem>
            <para>Filter on visible area as this can increase query
            speed.</para>
          </listitem>

          <listitem>
            <para>Post-process features filtering unreadable attributes, set
            update flags, remove features which are not allowed.</para>
          </listitem>
        </itemizedlist>

        <para>Commands:</para>

        <itemizedlist>
          <listitem>
            <para>configuration.Get and configuration.GetMap: layers which are
            invisible should be removed, tools which are not authorized should
            be removed, "editable" and "deletable" statusses on layers,
            features, attributes need to be set.</para>
          </listitem>

          <listitem>
            <para>configuration.UserMaximumExtent: max extent should only
            consider visible features.</para>
          </listitem>

          <listitem>
            <para>feature.PersistTransaction: making changes to attributes
            which are not editable should cause a security exception.</para>
          </listitem>

          <listitem>
            <para>feature.SearchByLocation: only return visible features and
            readable attributes.</para>
          </listitem>

          <listitem>
            <para>feature.SearchFeature: only return visible features and
            readable attributes.</para>
          </listitem>

          <listitem>
            <para>geometry.Get: only return the geometry for visible
            features.</para>
          </listitem>

          <listitem>
            <para>geometry.MergePolygon: no security implications.</para>
          </listitem>

          <listitem>
            <para>geometry.SplitPolygon: no security implications.</para>
          </listitem>

          <listitem>
            <para>render.GetRasterTiles: should only return data for visible
            layers, ideally post-processing the image to ensure only visible
            area is included (making the rest transparent).</para>
          </listitem>

          <listitem>
            <para>render.GetVectorTile: should only return data for visible
            layers, only display visible features, only return visible
            features, only render visible features. When attributes need to be
            included, only readable attributes should be included and the
            "editable" flag needs to be set.</para>
          </listitem>
        </itemizedlist>

        <para>Rendering:</para>

        <itemizedlist>
          <listitem>
            <para>The individual rendering steps (especially the layer/feature
            model) can use the <code>SecurityContext</code> to filter the data
            they produce.</para>
          </listitem>

          <listitem>
            <para>Images can have areas masked which are not allowed to be
            seen.</para>
          </listitem>

          <listitem>
            <para>The rendering pipeline can include steps which check the
            security. This can make life easier on the layer model which are
            not guaranteed (or forced) to handle all security aspects. These
            are active by default but can be removed for speed (when you are
            sure this is double work).</para>
          </listitem>
        </itemizedlist>

        <para>Cache:</para>

        <itemizedlist>
          <listitem>
            <para>The caching needs to consider the access rights when storing
            and retrieving data.</para>
          </listitem>
        </itemizedlist>

        <para>Client:</para>

        <itemizedlist>
          <listitem>
            <para>The client is responsible for assuring a authentication token
            is included in all access to the server.</para>
          </listitem>

          <listitem>
            <para>The "get configuration" commands filter the data to assure
            invisible layer and attributes and tools which are not allowed are
            not displayed. No action needed.</para>
          </listitem>

          <listitem>
            <para>Specific tests on editability of individual features and
            attributes would be useful to assure the user does try to enter or
            modify data which cannot be saved.</para>
          </listitem>

          <listitem>
            <para>The client should ask for credentials again when the token was
            not available or is no longer valid. Specifically when a
            <code>GeomajasSecurityException</code> is received which code
            <code>ExceptionCode.CREDENTIALS_MISSING_OR_INVALID</code>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="arch-sec-transport">
        <title>Server configuration</title>

        <para>While this is not really touched by description above, the
        following system configuration issues are likely to be important when
        you want to secure your Geomajas application.</para>

        <itemizedlist>
          <listitem>
            <para>Make sure the communication between the client and server
            uses encryption, possibly by using https. This prevents snooping
            of your data and/or hijacking the security token.</para>
          </listitem>

          <listitem>
            <para>Even if your application is using http for some reason, at
            the very least your authentication method should use https to
            prevent your passwords from being transmitted on the wire in
            cleartext. I would expect all authentication servers do
            this.</para>
          </listitem>

          <listitem>
            <para>Depending on your needs, it may make sense to store the data
            encrypted on the server. If you want that, your need a layer model
            which can access your secured data (possibly passing on the
            security token).</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </chapter>

  <chapter id="ch-projstruct">
    <title>Project structure</title>

    <para>The project is built from a large set of modules. A specific
    application can choose which modules are used or not. In principle, the
    server module are always required and at least one client and at least one
    layer plug-in. More plug-ins or clients can be added as needed.</para>

    <para></para>

    <section id="arch-auto-reg">
      <title>Plug-in registration</title>

      <para>Plug-ins are automatically discovered when
      available on the classpath. This is done using two files:
      META-INF/geomajasContext[suffix].xml and META-INF/geomajasWebContext[suffix].xml.</para>

	  <para>The suffix is meant to deal with classpath issues where context files
	  overwrite each other. Each plug-in can therefore define it's own geomajas(Web)Context.xml
	  file, the classpath is scanned for META-INF/geomajas(Web)Context*.xml</para>

      <para><itemizedlist>
          <listitem><para>The geomajasContext.xml file contains information about the
      plug-in, the dependencies for the plug-in (which are checked when the
      application context is built, assuring that the set of plug-ins is
      complete and can be combined) and contains copyright and license
      information for the plug-in and its dependencies. Additional beans and
      services can also be defined.</para></listitem>

          <listitem><para>The geomajasWebContext.xml file is provided to allow additional
      endpoints to be added in the web tier. Geomajas normally installs a
      <code>DispatcherServlet</code> in the web.xml file to allow additional
      web endpoints to be added using Spring MVC.</para></listitem></itemizedlist></para>
    </section>

    <section id="arch-module">
      <title>Module Overview</title>

      <para>Different modules have different impacts and different purposes.
      Therefore different categories of modules are required.
          In Geomajas server, modules can be categorizes as:</para>

      <para><itemizedlist>
          <listitem>
            <para><emphasis>core modules</emphasis>: these are essential Geomajas
            modules. Each Geomajas application needs these modules. However,
            you also need some a client and some plug-ins (like layers) or you
            won't be able to do much.</para>
          </listitem>

          <listitem>
            <para><emphasis>plug-in modules</emphasis>: modules that extend the Geomajas Server core function.
            This can either add new functionality, add support for a certain
            type of data source, provide a security service or a
            combination.</para>
          </listitem>

        </itemizedlist> Full list of Geomajas Server modules:</para>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas Server core modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-api</entry>

              <entry>Stable interfaces. Reference guide for other
              modules.</entry>
            </row>

            <row>
              <entry>geomajas-api-experimental</entry>

              <entry>Experimental interfaces. This contains some experimental
              stuff which may be promoted to the supported API when useful, or
              may be changed or dumped. As this is <emphasis>not</emphasis>
              part of the API, it may change between revisions.</entry>
            </row>

            <row>
              <entry>geomajas-command</entry>

              <entry>Lists all basic commands.</entry>
            </row>

            <row>
              <entry>geomajas-common-servlet</entry>

              <entry>Code which is shared by the different clients which are servlet based.</entry>
            </row>

            <row>
              <entry>geomajas-impl</entry>

              <entry>Main library with default implementations.</entry>
            </row>

            <row>
              <entry>geomajas-testdata</entry>

              <entry>Module which contains data which is used for testing
              Geomajas.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas Server plug-in modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-layer-geotools</entry>

              <entry>Support for any data format GeoTools supports and which has a GeoTools data store
                  defined for it (<ulink
                          url="http://geotools.org/javadocs/org/geotools/data/DataStore.html">http://geotools.org/javadocs/org/geotools/data/DataStore.html</ulink>).
                  This also allows access data from an ESRI shape file, handled in memory, using the <code>ShapeInMemLayer</code>.</entry>
            </row>

            <row>
              <entry>geomajas-layer-googlemaps</entry>

              <entry>Support for GoogleMaps raster format. This allows access to the normal and satellite views
                  provided by Google. You still have to make sure you comply with
                  Google terms of use (<ulink
                          url="http://code.google.com/apis/maps/">http://code.google.com/apis/maps/</ulink>)</entry>
            </row>

            <row>
              <entry>geomajas-layer-hibernate</entry>

              <entry>Support for database formats through Hibernate. Allow
                  access to any kind of features which are stored in a spatial
                  (relational) database. The data is accessed using the hibernate and
                  hibernate-spatial open source libraries.</entry>
            </row>

            <row>
              <entry>geomajas-layer-openstreetmap</entry>

              <entry>Support for raster data coming from the OpenStreetMap project
                  (<ulink
                          url="http://www.openstreetmap.org/">http://www.openstreetmap.org/</ulink>).</entry>
            </row>

            <row>
              <entry>geomajas-layer-wms</entry>

              <entry>Support for the WMS raster format. Access data from a WMS server (<ulink
                          url="http://www.opengeospatial.org/standards/wms">http://www.opengeospatial.org/standards/wms</ulink>).</entry>
            </row>

            <row>
              <entry>geomajas-plugin-cache</entry>

              <entry>Caching plug-in which allows improved speed by
              calculating data only once.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-geocoder</entry>

              <entry>Geocoder support, using various geocoding
              services.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-print</entry>

              <entry>Adds printing capabilities beyond printing in the
              browser, by delivering the map as PDF.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-rasterizing</entry>

              <entry>Rasterize vector layers on the server.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-reporting</entry>

              <entry>Build reports (using JasperReports) for features,
              possibly including a map.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-staticsecurity</entry>

              <entry>Simple security service which allows including the entire
              security configuration in the Spring configuration files.
                  It does not use an external source for users or policies,
                  making the configuration static.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>
</part>
